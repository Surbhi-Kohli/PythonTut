### Intro:
#### unittest Library in Python
unittest is Pythonâ€™s built-in unit testing framework used to write and run automated tests for Python code. It follows the xUnit testing framework design 
(used in JUnit for Java, NUnit for .NET, etc.)
Developers often choose Pythonâ€™s unittest framework for its built-in nature, widespread familiarity, comprehensive features,seamless integration with other tools, and proven reliability. 
As part of Pythonâ€™s standard library, unittest requires no additional installations, making it easily accessible.
Unit tests promote consistency in testing practices, aiding collaboration and maintenance.
While other frameworks like Pytest and nose offer alternatives, unittest remains a popular choice for its stability and versatility.

### ğŸ”¹ Basic Structure of unittest
A unittest test case is a class that inherits from unittest.TestCase

calc.py:

```

def add(x, y):
    """Add Function"""
    return x + y


def subtract(x, y):
    """Subtract Function"""
    return x - y


def multiply(x, y):
    """Multiply Function"""
    return x * y


def divide(x, y):
    """Divide Function"""
    if y == 0:
        raise ValueError('Can not divide by zero!')
    return x / y
```
Inorder to unit test the above functionality, we will create a test file with name test_calc.py.Its a naming convention to use test_ for a test file.
test_calc.py:

```
import unittest  # This module is in standard library, no need to install
import calc # import the module that you need to test


class TestCalc(unittest.TestCase): # Class inheritis from unittest.TestCase , this is important so as to get testing capabilities/functions within that class

        # just like any method in a class, self is passed as 1st arg
    def test_add(self): # import naming convention
        self.assertEqual(calc.add(10, 5), 15) # âœ… Passes  
        self.assertEqual(calc.add(-1, 1), 0) # âœ… Passes
        self.assertEqual(calc.add(-1, -1), -2) # âœ… Passes

    def test_subtract(self):
        self.assertEqual(calc.subtract(10, 5), 5) # âœ… Passes
        self.assertEqual(calc.subtract(-1, 1), -2) # âœ… Passes
        self.assertEqual(calc.subtract(-1, -1), 0) # âœ… Passes

    def test_multiply(self):
        self.assertEqual(calc.multiply(10, 5), 50)
        self.assertEqual(calc.multiply(-1, 1), -1)
        self.assertEqual(calc.multiply(-1, -1), 1)

    def test_divide(self):
        self.assertEqual(calc.divide(10, 5), 2)
        self.assertEqual(calc.divide(-1, 1), -1)
        self.assertEqual(calc.divide(-1, -1), 1)
        self.assertEqual(calc.divide(5, 2), 2.5)
        
        # testing that an exception is raised, can be done in 2 ways:
        # 1st way: self.assertRaises(ValueError,calc.divide,10,0)

       # we cant do self.assertEqual(calc.divide(10,0),ValueError) as this would raise an exception in our test and our test will think that it failed

        # 2nd way: with context manager
        with self.assertRaises(ValueError):
            calc.divide(10, 0)

# Run tests when script is executed
if __name__ == '__main__':
    unittest.main()

```
Inorder to run the test:
```
python test_calc.py # works only if in ur code u added if __name..., unittest.main() part of code

python -m unittest test_calc.py # runs the tests

```
#### Important conventions and explanations :
1. Keep the file name which contains test cases as test_{xyz}.py
2. Keep the function names that contain test cases as test_{functionality} or else the function will not be considered as a test function and will be skipped during test run.
3. Since our TestCalc inherited from unittest.TestCase, we are able to access assertion methods like assertEqual, etc

#### What is self in the test functions and how does it get the assertEqual and other testing functions :

In your test class, self is an instance of TestCalc, which inherits from unittest.TestCase.
This inheritance provides self with all the built-in assert methods like self.assertEqual() and self.assertRaises().

##### ğŸ›  Where Does self Come From?
When you run:
```python test_calc.py```
* unittest.main() discovers all test methods that start with ```test_```.
* For each test method:
  * It creates a new instance of TestCalc. TestCalc inherits from unittest.TestCase, which provides built-in assert methods.(Important: new instance for each test case)
  * It calls the method (e.g., test_add()).
  * It provides self, which is the instance of TestCalc.
This is why ```self.assertEqual()``` worksâ€”it is inherited from ```unittest.TestCase```

##### ğŸ”‘ Key Takeaways
 * self refers to an instance of the test class.
 * self gets assertion methods (assertEqual(), assertRaises(), etc.) from unittest.TestCase.
 * Each test method runs in its own instance to avoid state leakage between tests.
 * unittest.main() automatically finds and runs all test methods.

####  what is unittest.main and how does it execute the code in my test file 
``` if __name__ == "__main__":
          unittest.main()
   ```
It is a command-line program that loads a set of tests from module and runs them; this is primarily for making test modules conveniently executable. The simplest use for this function is to include the following line at the end of a test script:
```
if __name__ == '__main__':
    unittest.main()
```
You can run tests with more detailed information by passing in the verbosity argument:
```
if __name__ == '__main__':
    unittest.main(verbosity=2)
```
 unittest.main() is a function provided by Python's built-in unittest module. It serves as the entry point for running test cases in your test script. When executed, it discovers and runs all test methods defined in the test file.   

 #### How does unittest.main() Work?
When you include:
```
if __name__ == "__main__":
    unittest.main()
```
it does the following:

 1. Detects Test Cases
    * It scans the test file for classes that inherit from unittest.TestCase.
    * It finds all methods in those classes that start with test_.
 2. Runs the Tests
    * Each test method is executed.
    * setUp() and tearDown() (if defined) are called before and after each test.
    * The results (pass, fail, or error) are collected.
 3. Displays the Results
   * The test output is printed to the console in a summary format.



### Asserting for Exceptions in unit tests:

Using with self.assertRaises(ValueError): is generally more readable, flexible, and better for debugging compared to self.assertRaises(ValueError, func, *args). Let's go deeper into each reason.

#### âœ… 1ï¸âƒ£ More Readable & Pythonic
â€œThe test clearly states: â€˜this block should raise a ValueError.â€™â€

#####ğŸ”¹ Context Manager Approach:
```
with self.assertRaises(ValueError):
    calc.divide(10, 0)
```
âœ… Clear Intent â†’ The with block explicitly states: â€œThe following code must raise a ValueErrorâ€.
âœ… No Function Signature Confusion â†’ The function is called normally, just like in real usage.
âœ… Easier to Extend â†’ If you need to add more operations inside the block (e.g., more function calls), you can easily do so.

##### âŒ Non-Context Manager Approach:
```
self.assertRaises(ValueError, calc.divide, 10, 0)
```
ğŸš« Less Intuitive â†’ The function is passed as an argument to assertRaises, making it look different from how it would normally be called.
ğŸš« Harder to Extend â†’ If you later need to test multiple function calls together, you'd have to refactor the test.

ğŸ“Œ Example: Testing Multiple Calls
If you need to check multiple function calls, the context manager makes it simple:
```
with self.assertRaises(ValueError):
    calc.divide(10, 0)
    calc.divide(20, 0)  # Easy to add more calls
```
With self.assertRaises(ValueError, calc.divide, 10, 0), you'd need multiple lines, making it less compact.

#### âœ… 2ï¸âƒ£ Supports Additional Assertions
â€œYou can check exception messages or perform extra validations inside the block.â€

##### ğŸ”¹ Context Manager Approach:
```
with self.assertRaises(ValueError) as cm:
    calc.divide(10, 0)

self.assertEqual(str(cm.exception), "Cannot divide by zero")
```
âœ… Access Exception Object â†’ The as cm part lets us inspect the raised exception.
âœ… Validate Error Message â†’ We can check that the correct error message was returned.
âœ… More Robust Testing â†’ Helps ensure the function raises the right error for the right reason.

##### âŒ Non-Context Manager Approach:
```
self.assertRaises(ValueError, calc.divide, 10, 0)
```
ğŸš« No Access to Exception Object â†’ You cannot check the error message or its attributes.
ğŸš« Limited Debugging â†’ If a function raises the wrong error, you wonâ€™t see why without additional print statements.

ğŸ“Œ Example: Validating Multiple Exception Properties
With the context manager, you can even check more attributes:

```
with self.assertRaises(ValueError) as cm:
    calc.divide(10, 0)

exception_obj = cm.exception
self.assertEqual(str(exception_obj), "Cannot divide by zero")
self.assertIsInstance(exception_obj, ValueError)  # Extra check
```
This isn't possible with self.assertRaises(ValueError, func, *args), which only checks the exception type.
#### âœ… 3ï¸âƒ£ Better Debugging & Stack Tracing
â€œIf an unexpected error occurs, it's easier to pinpoint the failure.â€

#####ğŸ”¹ Context Manager Approach:
```
with self.assertRaises(ValueError):
    calc.divide(10, 0)
```
âœ… Detailed Stack Trace â†’ If an unexpected error occurs, the stack trace shows exactly which line caused it.
âœ… Easier Debugging â†’ Each function call inside the block is treated separately.
âœ… Less False Positives â†’ Ensures the correct part of the test fails if something goes wrong.

##### âŒ Non-Context Manager Approach:

self.assertRaises(ValueError, calc.divide, 10, 0)
ğŸš« Harder to Debug â†’ If an unexpected exception occurs, you wonâ€™t see which line failed in the traceback.
ğŸš« No Intermediate Stack Info â†’ If calc.divide internally calls another function that fails, the error trace may not be as clear.

ğŸ“Œ Example: Debugging an Unexpected Error
Imagine calc.divide(10, 0) raises a ZeroDivisionError instead of a ValueError.

With the Context Manager:

```
Traceback (most recent call last):
  File "test_calc.py", line 10, in test_divide
    calc.divide(10, 0)
ZeroDivisionError: division by zero
```
âœ… Pinpoints the problem â†’ Shows exactly which line in the test failed.

With self.assertRaises(ValueError, calc.divide, 10, 0)


AssertionError: ValueError not raised
ğŸš« No Context â†’ It only tells us the test failed, but not why.
