## Multithreading in Python:
We would use threading to significantly increase the speed of program by running diff tasks concurrently 

```
import time

start = time.perf_counter()


def do_something(seconds):
    print(f'Sleeping {seconds} second(s)...')
    time.sleep(seconds)
    return f'Done Sleeping...{seconds}'

do_something(1) # while this sleeps, there is no cpu computation, cpu does not work for this script till sleep time is over
do_something(1)
do_something(1)

finish = time.perf_counter()


print(f'Finished in {round(finish-start, 2)} second(s)')

# output:
# Sleeping 1 second(s)...
# Sleeping 1 second(s)...
# Sleeping 1 second(s)...
# Finished in 3.0 second(s)
```
All the do_something calls are synchronous and CPU remains idle during the sleep.
This is a sign that we could improvise using threading and concurrency
![Screenshot 2025-02-01 at 4 16 00 PM](https://github.com/user-attachments/assets/331d27c7-8986-49b0-9c4b-29813118248d)

### CPU bound vs IO bound tasks:
CPU bound tasks are things that are crunching a lot of numbers and using the CPU; and the I/O bound tasks are things that are just waiting for input and output operations to be completed and not really using the CPU that much.
Example of IO bound task: reading/writing from the file system and other file system operations, network operations, downloading stuff online,etc

When it comes to threading , we see its benefits when our tasks are IO bound which means we are doing a lot of waiting around for input and output operations like reading data from disk or network operations.
If used in wrong case, some programs end up being slower because of thread because of the overhead of creating and destroying different threads.

### Multithreading 
Multithreading does not run the code exactly at same time, it just gives an illusion of running code at the same time.The image below illustrates the same.

![Screenshot 2025-02-01 at 4 32 12 PM](https://github.com/user-attachments/assets/122d8ab2-6a58-46a7-9070-82eed6f17a21)

Older way of adding threading in the python code:

```
import threading
import time

start = time.perf_counter()


def do_something():
    print(f'Sleeping 1 second(s)...')
    time.sleep(1)
    print('Done Sleeping...')

# Threads creation
t1 =  threading.Thread(target = do_something)
t2 =  threading.Thread(target = do_something)

# To run the threads
t1.start()
t2.start()

finish = time.perf_counter()


print(f'Finished in {round(finish-start, 2)} second(s)')


# Output:
# Sleeping 1 second(s)...
# Sleeping 1 second(s)...
# Finished in 0.0 second(s) # when the threads started, the execution went to next step, (without waiting for the threads to complete execution); which is finish time calculation
# Done Sleeping...
# Done Sleeping...


```

Since the threads run in parallel, the total execution time remains ~1 second instead of 2 seconds (if run sequentially).

Now what if we want the the finish time to be calculated only after both the threads are done with execution . For this we will use join method

```
import threading
import time

start = time.perf_counter()


def do_something():
    print(f'Sleeping 1 second(s)...')
    time.sleep(1)
    print('Done Sleeping...')

# Threads creation
t1 =  threading.Thread(target = do_something)
t2 =  threading.Thread(target = do_something)

# To run the threads
t1.start()
t2.start()

t1.join()
t2.join()

finish = time.perf_counter()

# Output:
# Sleeping 1 second(s)...
# Sleeping 1 second(s)...
# Done Sleeping...
# Done Sleeping...
# Finished in 1.0 second(s)

```

