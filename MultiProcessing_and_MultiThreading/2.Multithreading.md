## Multithreading in Python:
We would use threading to significantly increase the speed of program by running diff tasks concurrently 

```
import time

start = time.perf_counter()


def do_something(seconds):
    print(f'Sleeping {seconds} second(s)...')
    time.sleep(seconds)
    return f'Done Sleeping...{seconds}'

do_something(1) # while this sleeps, there is no cpu computation, cpu does not work for this script till sleep time is over
do_something(1)
do_something(1)

finish = time.perf_counter()


print(f'Finished in {round(finish-start, 2)} second(s)')

# output:
# Sleeping 1 second(s)...
# Sleeping 1 second(s)...
# Sleeping 1 second(s)...
# Finished in 3.0 second(s)
```
All the do_something calls are synchronous and CPU remains idle during the sleep.
This is a sign that we could improvise using threading and concurrency
![Screenshot 2025-02-01 at 4 16 00 PM](https://github.com/user-attachments/assets/331d27c7-8986-49b0-9c4b-29813118248d)

### CPU bound vs IO bound tasks:
CPU bound tasks are things that are crunching a lot of numbers and using the CPU; and the I/O bound tasks are things that are just waiting for input and output operations to be completed and not really using the CPU that much.
Example of IO bound task: reading/writing from the file system and other file system operations, network operations, downloading stuff online,etc

When it comes to threading , we see its benefits when our tasks are IO bound which means we are doing a lot of waiting around for input and output operations like reading data from disk or network operations.
If used in wrong case, some programs end up being slower because of thread because of the overhead of creating and destroying different threads.

### Multithreading 
Multithreading does not run the code exactly at same time, it just gives an illusion of running code at the same time.

![Screenshot 2025-02-01 at 4 32 12 PM](https://github.com/user-attachments/assets/122d8ab2-6a58-46a7-9070-82eed6f17a21)

